# Task Scheduler (rust)

Task Scheduler is a modern, high-performance task execution platform written in Rust. It enables clients to submit, manage, and execute complex workflows via a gRPC interface defined using Protocol Buffers. Built to scale, the system leverages Rust's concurrency and async capabilities to ensure fast, robust, and safe task execution.

## Overview

Task Scheduler provides a powerful backend for executing various tasks with support for both synchronous and asynchronous operations. Tasks, along with their parameters and dependencies, are transmitted as Protobuf `Any` messages. These messages are then converted into native types within the system, ensuring type safety and efficient processing.

## Architecture & Design

### Task Registration and Execution

- **Registration with Macros:**  
  Tasks are registered at compile time using the custom `#[task]` macro. This macro automatically injects the necessary code to register the function into a global registry (using the [`ctor`](https://crates.io/crates/ctor) crate) so that the task is available when the application starts.

- **Global Task Registry:**  
  The registry maintains separate collections for synchronous and asynchronous tasks. Each task is identified by a unique method string (e.g., `task_scheduler::tasks::builtin::add`) generated by the macro.

- **Execution Modes:**  
  - *Single Task Execution:* Tasks are executed one-by-one via the `execute_task` method.  
  - *Parallel Task Execution:* Independent tasks are executed concurrently using Rayon. Tasks with dependencies are scheduled in wavesâ€”each wave is executed only when all dependencies are met. Temporary caching is used to store intermediate results.

### gRPC Interface and Proto Integration

- **Protobuf Definition:**  
  The RPC interface is defined in the `proto/task_scheduler.proto` file, which includes two key endpoints:
  1. **SubmitTask:** Accepts a task request comprising a task ID, method name, arguments (encoded as `google.protobuf.Any`), a list of dependencies, and an execution mode flag (synchronous or asynchronous).
  2. **GetResult:** Retrieves the result for a given task based on its task ID.

- **Communication Flow:**  
  Clients serialize task parameters into `Any` messages before sending them over gRPC. The backend deserializes these messages back into native Rust types and routes them to the respective task functions for execution.

### Argument Conversion and Dependency Management

- **Parameter Handling:**  
  All incoming parameters are converted from their Protobuf `Any` representations into an internal `ArgValue` enum. This enum supports a variety of types including:
  - Integers (signed and unsigned)
  - Floating point numbers
  - Booleans
  - Strings
  - Byte arrays
  - Arrays and Maps

- **Dependency Tracking:**  
  If a task depends on the result(s) of other tasks, the scheduler verifies that all dependencies are completed by checking a sharded LRU cache. If any dependency is missing or remains incomplete, the task fails gracefully with an appropriate error message.

### High Performance and Scalability

1. **Concurrent Data Structures:**  
   The global task registry is implemented using DashMap, an efficient, lock-free concurrent hashmap, ensuring minimal contention in a multi-threaded environment.

2. **Parallel Execution:**  
   Independent tasks are executed in parallel using Rayon. This takes full advantage of multi-core systems to speed up overall task processing.

3. **Asynchronous Runtime:**  
   Asynchronous tasks run on the Tokio runtime, which provides non-blocking I/O and efficient scheduling for high-concurrency environments.

4. **Sharded LRU Caching:**  
   Intermediate task results are stored in a sharded LRU cache, where each shard is protected by a low-overhead mutex (via the `parking_lot` crate). This design minimizes lock contention while allowing fast access to cached results, essential for dependency resolution.

5. **Efficient Serialization:**  
   Prost is employed for Protobuf handling, ensuring that message serialization and deserialization are performed quickly and with minimal overhead.

## Usage

### Registering Tasks

Register tasks at compile time using the `#[task]` macro. For example:

```rust
use crate::tasks::task;
use crate::models::ArgValue;

#[task]
pub fn add(args: Vec<ArgValue>) -> String {
    // Convert and calculate sum...
}

#[task]
pub fn remove(args: Vec<ArgValue>) -> String {
    // Convert and execute subtraction...
}

#[task]
pub async fn delete(args: Vec<ArgValue>) -> String {
    // Async deletion task...
}
```

### gRPC Endpoints

The backend exposes two primary gRPC endpoints:

- **SubmitTask:**  
  Submit a new task by providing a unique task ID, the method name, arguments (as `Any` messages), a dependency list, and an execution mode indicator.
  
- **GetResult:**  
  Retrieve the outcome of a previously submitted task by its task ID. If the task has completed, the result is returned immediately.

## CLI and gRPC Usage

### Starting the Server

The server is started via a command-line interface built with the `clap` crate. The CLI accepts an `--addr` (or `-a`) option to specify the listening address.

#### CLI Format

```bash
cargo run -- --addr "[::1]:50051"
```

- If no address is provided, the default `[::1]:50051` is used.

### gRPC Message Format

The RPC interface is defined in the `proto/task_scheduler.proto` file. The two main RPC calls are:

1. **SubmitTask:**  
  This call accepts a `TaskRequest` with the following fields:
  - `task_id`: A unique task identifier.
  - `method`: The method name (for example, `"task_scheduler::tasks::builtin::add"`).
  - `args`: An array of arguments encoded as `google.protobuf.Any` messages. For instance:
    - For an integer, the `Any` message's `type_url` is `"type.googleapis.com/google.protobuf.Int32Value"`.
    - For a boolean, it is `"type.googleapis.com/google.protobuf.BoolValue"`.
  - `deps`: A list of dependent task IDs.
  - `is_async`: A flag to indicate asynchronous task execution.

  A sample JSON representation might be:

  ```json
  {
    "task_id": "task_123",
    "method": "task_scheduler::tasks::builtin::add",
    "args": [
      {
        "type_url": "type.googleapis.com/google.protobuf.Int32Value",
        "value": "CgYIARgB" // Base64 encoded Int32Value message
      }
    ],
    "deps": [],
    "is_async": false
  }
  ```

2. **GetResult:**  
  This call accepts a `ResultRequest` containing just the `task_id`, and returns a `ResultResponse` with:
  - `result`: The result of the task as a string.
  - `is_ready`: A boolean indicating whether the task has completed.

This design allows clients to interact with the server efficiently using gRPC.
